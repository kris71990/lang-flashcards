# Polyglot's Corner - Backend

**Author:** Kris Sakarias

**Version** 2.0.0

----

## Overview

This is a flashcard application that helps people learn new languages. Users select a language to cycle through vocabulary, words and phrases in a flashcard style interface to improve foreign language skills. Users can sign up to add words and track their progress. 

This is the backend directory. The server and API is built with **Node** and **Express**. It utilizes a relational database using **PostgreSQL**, which is managed by **Sequelize**. Unit tests are written using **Jest**. Load testing of the server will be conducted with **Artillery**.


## Getting Started

1. Clone the parent repo: `git clone https://github.com/kris71990/lang-flashcards.git`
2. Create a `.env` file in in the backend directory and include the environment variables listed below
3. `npm i` to install necessary node modules

**Environment variables**

- `NODE_ENV=development`
- `PORT=3000`
- `CLIENT_URL=http://localhost:8080`
- `DATABASE_URL=postgres://localhost:5432/flashcards`
- `ACCOUNT_SECRET={Any String}`

**Create Local Database**

In the **PostgreSQL** shell (psql), create a local database for the application: `CREATE DATABASE flashcards;`.

**Start the Server**

From the root of the backend directory, start the server with `npm run start`.

----

## Documentation

**Database Models**

A Postgres relational database is used for data storage. There are four models used to structure application data. 

```Account ---> Profile```

```Language ---> Word```

Every account is related to one profile (1:1). Every language is related to multiple words (1:many). This basic structure guarantees the relationships of data necessary to developing the application. 

----

**Routing and Functionality**

*Account Router*

The account router handles account creation and login. Account and profile data is secured by encrypted access tokens with JWT. 

1. POST /signup
  - User must sign up with a `username`, `password`, and `email`
  - If user data is validated on the frontend, the server will create an account

  During signup, the password is hashed and stored while the password itself is immediately deleted. An authentication token is created and returned via a cookie. 

2. GET /login
  - User must log in with their `username` and `password`
  - The password is hashed and compared with the stored password hash
  - A token is returned if the hashes match, and the user is logged in


*Profile Router*

1. POST /profile
  - A profile is automatically created when a user signs in for the first time.
  - Only two pieces of data exist on the user profile
    - `name` - by default, the account's username
    - `languages` - by default, an empty array to be updated as the app is used

2. GET /profile/me
  - When requested, authenticates user and returns their profile

3. PUT /profile/:id
  - The data updated in the profile depends on the shape and contents of the request body. 
  Scenario 1
    - `request.body => { name }`
    - profile's name is updated
  Scenario 2
    - `request.body => { language }`
    - language is added to profile's language array
    - language is an object that includes
      - name of language 
      - words added (to keep track of number of words the user creates for the language)
      - score (array used to track the progress as the user practices)
      - skill level (generated by analyzing the score)
      - date added (date object used to track how long the user has been practicing)
  Scenario 3
    - `request.body => { language: { language } }` 
    - language is deleted from profile's language array if the language's value is an object
  Scenario 4
    - `request.body => { language, score }`
    - user score is updated for the given language
    - if language does not exist, it is created and score is updated
  Scenario 5
    - `request.body => { language, words }`
    - when user adds words for a language, the words number is incremented 


*Language Router*

1. POST /language
  - Users can add a language if it doesn't already exist
  - A language is created with some basic data:
    - `languageId` - uuid for access
    - `languageName` - name of langauge 
    - `wordCount` - number of words entered (initialized to zero)

    This biographical data is extracted from local json
    - `transliteration` - boolean (true if language uses a non-latin alphabet)
    - `totalSpeakers` - estimated number of speakers around the world
    - `family` - family tree of the language (array)
    - `spokenIn` - primary countries the language is spoken in (array)

2. GET /language/all
  - Returns all languages


*Word Router*

1. POST /word
  - Users can add a single word for a particular language
  - A word is created with:
    - `wordEnglish` - word in english (string)
    - `wordLocal` - word in local language (string)
    - `typeOfWord` - part of speech of the word (string)
    - `category` - what does the word relate to (i.e. food, clothing etc, string)
    - `languageId` - language the word should be added to (uuid)
  - If word already exists, the existing version is returned and the `wordCount` on the language object is incremented

2. POST /words/bulk
  - Users can add multiple words at a time 
  - Words are created with the same data as above, where each string is an index in an array 
  - All data is processes and added, `wordCount` on language object is incremented

3. GET /words/:language
  - All words for the given language are returned 

4. PUT /word/:id
  - Word data is updated

5. DELETE /word/:id
  - Word is deleted

----

## Testing

Unit testing with **Jest**
Load testing with **Artillery**
